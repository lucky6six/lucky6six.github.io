/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SpellcheckTogglerPlugin
});
module.exports = __toCommonJS(main_exports);

// src/plugin.ts
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var defaultSettings = {
  spellcheckExternalLinks: false,
  spellcheckInternalLinks: false,
  spellcheckHtmlComments: true
};
var SpellcheckTogglerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Enable spellcheck for external links").setDesc(
      "Toggle spellcheck underline for link text in any external link."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.spellcheckExternalLinks).onChange(
        (value) => this.plugin.saveSettings({
          spellcheckExternalLinks: value
        })
      )
    );
    new import_obsidian.Setting(containerEl).setName("Enable spellcheck for internal links").setDesc(
      "Toggle spellcheck underline for link text for in any internal link."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.spellcheckInternalLinks).onChange(
        (value) => this.plugin.saveSettings({
          spellcheckInternalLinks: value
        })
      )
    );
    new import_obsidian.Setting(containerEl).setName("Enable spellcheck for html comments").setDesc(
      "Toggle spellcheck underline for any text inside an html comment block."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.spellcheckHtmlComments).onChange(
        (value) => this.plugin.saveSettings({
          spellcheckHtmlComments: value
        })
      )
    );
  }
};

// src/spellchecks/html.ts
var import_view2 = require("@codemirror/view");

// src/spellchecks/logic.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");
var ApplySpellcheckAttributePluginValue = class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (!update.docChanged && !update.viewportChanged)
      return;
    this.decorations = this.buildDecorations(update.view);
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    const markSpellcheckFalse = import_view.Decoration.mark({
      attributes: { spellcheck: "false" }
    });
    const enter = (node) => {
      var _a;
      if ((_a = this.isNodeEligible) == null ? void 0 : _a.call(this, node))
        builder.add(node.from, node.to, markSpellcheckFalse);
    };
    for (let { from, to } of view.visibleRanges)
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter
      });
    return builder.finish();
  }
};

// src/spellchecks/html.ts
var HtmlCommentSpellcheckPluginValue = class extends ApplySpellcheckAttributePluginValue {
  isNodeEligible(node) {
    return node.type.name.startsWith("comment");
  }
};
var htmlCommentSpellcheckPluginValue = import_view2.ViewPlugin.fromClass(
  HtmlCommentSpellcheckPluginValue,
  {
    decorations: (pluginValue) => pluginValue.decorations
  }
);

// src/spellchecks/links.ts
var import_view3 = require("@codemirror/view");
var InternalLinkSpellcheckPluginValue = class extends ApplySpellcheckAttributePluginValue {
  isNodeEligible(node) {
    return node.type.name.startsWith("hmd-internal-link");
  }
};
var internalLinkSpellcheckViewPlugin = import_view3.ViewPlugin.fromClass(
  InternalLinkSpellcheckPluginValue,
  {
    decorations: (pluginValue) => pluginValue.decorations
  }
);
var ExternalLinkSpellcheckPluginValue = class extends ApplySpellcheckAttributePluginValue {
  isNodeEligible(node) {
    return node.type.name.startsWith("link");
  }
};
var externalLinkSpellcheckViewPlugin = import_view3.ViewPlugin.fromClass(
  ExternalLinkSpellcheckPluginValue,
  {
    decorations: (pluginValue) => pluginValue.decorations
  }
);

// src/plugin.ts
var SpellcheckTogglerPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.editorExtensions = [];
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      defaultSettings,
      await this.loadData()
    );
  }
  async saveSettings(settings) {
    this.settings = { ...this.settings, ...settings };
    this.refreshExtensions();
    await this.saveData(this.settings);
  }
  buildExtensions() {
    this.editorExtensions.length = 0;
    if (!this.settings.spellcheckInternalLinks)
      this.editorExtensions.push(internalLinkSpellcheckViewPlugin);
    if (!this.settings.spellcheckExternalLinks)
      this.editorExtensions.push(externalLinkSpellcheckViewPlugin);
    if (!this.settings.spellcheckHtmlComments)
      this.editorExtensions.push(htmlCommentSpellcheckPluginValue);
  }
  refreshExtensions() {
    this.buildExtensions();
    this.app.workspace.updateOptions();
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SpellcheckTogglerSettingTab(this.app, this));
    this.buildExtensions();
    this.registerEditorExtension(this.editorExtensions);
  }
};
